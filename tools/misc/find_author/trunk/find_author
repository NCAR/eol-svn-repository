#!/usr/bin/perl -wT

# ------------------------------------------------------------------------------
use DBI;
my $dbh = connectToDB();
# ------------------------------------------------------------------------------

# Run the script
&main();

sub main {
  open(OUT, ">authors.data.txt") or die ("Unable to open authors.data.txt\n");
  open(POSS, ">possible.authors.txt") or die ("Unable to open possible.authors.txt\n");
  open(FNF, ">notfound.txt") or die ("Unable to open notfound.txt\n");
  open(NCAR, ">ncar-eol.txt") or die ("Unable to open ncar-eol.txt\n");
  open(EMPTY, ">zeroauthors.txt") or die ("Unable to open zeroauthors.txt\n");
  open(LOG, ">results.log") or die ("Unable to open results.log\n");
  #my @keywords = (",", "and", " et al.", "/");

  open(NAMES, "names.txt") or die ("Unable to open names.txt\n");
  my @names = <NAMES>;
  close(NAMES);

  my $query = "SELECT id, short_name, person_name, organization_name FROM contact where ";
  my $sql = "";
  my $sth;

  foreach my $line(@names) {
    chomp($line);
    my ($project, $ml_id, $authors) = split(/\s\|\s/, $line, 3);
    my @sp_authors;

    # Skip this line if prefixed with a "#"
    if ( $line =~ m/^\#/ ) { next; }

print "$line\n";
print LOG "$line\n";

    if ( !defined($authors) || $authors =~ m/^\s*$/ || $authors eq "" ) {
      # Add this line to "not found" file and skip the rest of this loop
      print EMPTY "$ml_id | $project | \n"; #$authors\n";
print LOG "\t\tEMPTY\n\n";
      next;
    } else {
      my $auth_pi = $authors;
      $auth_pi =~ s/[\s]+et al\.//g;
      if ( $auth_pi =~ m/\w\,\s+and\s+/ ) { $auth_pi =~ s/\s+and\s+/ /g; } elsif ( $auth_pi =~ m/\w[^\,]\s+and\s+/ ) { $auth_pi =~ s/\s+and\s+/, /g; }
#print "$auth_pi\n";

      # Split out this line for searching individual terms
      @sp_authors = split(/,[\s]*/, $auth_pi);

      # Special handling for a Lastname, Firstname and Firstname Lastname
      if ( scalar(@sp_authors) == 2 && $auth_pi =~ m/\s+and\s+/ ) {
        $auth_pi =~ s/\s+and\s+/\, /g;
        @sp_authors = split(/,\s*/, $auth_pi);
      }

      # Special handling for the organizations/PIs joined by a "/"
      if ( $auth_pi =~ m/\// && ( $auth_pi !~ m/NCAR[\/\-]/ && $auth_pi !~ m/[\/\-]RAF/ && $auth_pi !~ m/EOL[\/\-]/ ) ) {
        if ( scalar(@sp_authors) == 1 && $auth_pi =~ m/\// ) {
          # Special handling for a PIname/Organization
          $auth_pi =~ s/\// and /g;
          $sp_authors[0] = $auth_pi;
        } else {
          $auth_pi =~ s/\//, /g;
          @sp_authors = split(/,[\s]*/, $auth_pi);
        }
      } elsif ( $auth_pi =~ m/NCAR[\/\-]/ || $auth_pi =~ m/[\/\-]RAF/ || $auth_pi =~ m/EOL[\/\-]/ ) {
        # Add this line to "ncar-eol" file and skip the rest of this loop
        print NCAR "$ml_id | $project | $authors\n";
print LOG "\t$auth_pi\tNCAR\n\n";
        next;
      }

      # Special handling for the first author listed (originally LastName, FirstName)
      if ( scalar(@sp_authors) > 1 ) { 
        my $firstAuthor = $sp_authors[1]." ".$sp_authors[0];
        shift(@sp_authors);
        shift(@sp_authors);
        unshift(@sp_authors, $firstAuthor);
      }

      # Split any other things currently joined with an "and"
      foreach my $eachAuthor (@sp_authors) {
        if ( $eachAuthor =~ m/\s+and\s+/ ) { 
          my @splitAuthors = split(/\s+and\s+/, $eachAuthor);
          pop(@sp_authors); # Remove the last element which contains the "and"
          foreach my $iSplit(@splitAuthors) { push(@sp_authors, $iSplit) if ( $iSplit ne "" ); }
        }
      }
    }

    my $pi_found = 0;
    my $first_possible = 0;
    my $possibles = 0;
    my @new_pis;
    foreach my $a_pi (@sp_authors) {
#print "$ml_id\t$a_pi\t";
      my $a_name = $a_pi;
      $a_name =~ s/\./ /g;
      $a_name =~ s/\s/\%/g;
      $sql = $query . "short_name like \"%$a_name\" or person_name like \"%$a_name\" or organization_name like \"%$a_name\" order by id";
#print "$sql\n";

#    $sql = $query;
#    foreach my $a_pi (@sp_authors) {
#      if ($sql ne $query) { $sql = $sql . " or "; }
#      $sql = $sql . " short_name like \"%$a_pi%\" or person_name like \"%$a_pi%\" or organization_name like \"%$a_pi%\"";
#    }
#    $sql = $sql . " order by id";
#    print "\n$sql\n";

      $sth = $dbh->prepare( $sql );
      my $result_size = $sth->execute() or warn "Unable to execute QUERY: $sql\n";

      $possibles = 0;
      # If no results were found, try querying for the last name of the author
      if ( scalar($result_size) == 0 ) {
        my @full_name = split('%', $a_name);
        my $l_name = pop(@full_name);

        $sql = $query . "short_name like \"%$l_name\" or person_name like \"%$l_name\" or organization_name like \"%$l_name\" order by id";
#print "$l_name\n";
#print "$sql\n";
        $sth =  $dbh->prepare( $sql );
        $result_size = $sth->execute() or warn "Unable to execute QUERY: $sql\n";
        if ( scalar($result_size) != 0 ) { $possibles = 1; }
      }

      my $file = OUT;
#print "$a_pi\n\tpi_found: $pi_found\tfirst_possible: $first_possible\tpossibles: $possibles\n";
     # Handle the results of the query/queries
      if ( scalar($result_size) != 0 ) {
        # Add line to POSS if first possible match for this dataset
        if ( $possibles == 1 ) { 
          $file = POSS;
          if ( $first_possible == 0 ) {
            $first_possible = 1; 
            print $file "$ml_id\t$project\t[ $authors ]\n";
          }
        }
        # Add line to POSS if first confirmed match for this dataset (and not a possible match)
        if ( $pi_found == 0 && $possibles == 0 ) {
          $pi_found = 1; # A match was found;
          print $file "$ml_id\t$project\t[ $authors ]\n";
        }
#print "$file\n";
          print $file "  - $a_pi\n";
          while ( my @row = $sth->fetchrow_array() ) {
            print $file "\t";
            foreach my $val (@row) {
              $val = "" if (!defined($val));
              print $file "$val\t";
            }
            print $file "\n";
          }
print "\t$a_pi\t$file\n";
print LOG "\t$a_pi\t$file\n";
      } else {
          push(@new_pis, $a_pi);
print "\t$a_pi\tFNF\n";
print LOG "\t$a_pi\tFNF\n";
      }
#print "$a_pi\n\tpi_found: $pi_found\tfirst_possible: $first_possible\tpossibles: $possibles\n";
    }
  
    # If the "new PIs" array is not empty, then add these entries to the "notfound.txt" file
    if ( scalar(@new_pis) > 0 ) {
      my $join_new_pis = join(", ", @new_pis);
      print FNF "$ml_id | $project | $join_new_pis\n";
    }
print "\n";
print LOG "\n";
  }

  # Always disconnect cleanly
  $sth->finish() or warn "Statement handler failed to be destroyed with finish call\n";
  $dbh->disconnect() or warn "Disconnection failed: $DBI::errstr\n";
  close(LOG);
  close(EMPTY);
  close(NCAR);
  close(FNF);
  close(POSS);
  close(OUT);
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------


#-----------------------------------------------------------------
# Connect to the database 
#-----------------------------------------------------------------
sub connectToDB
{
  # Uncomment this section if using the test database on Sferic-Dev. #
#  return DBI->connect( "DBI:mysql:database=zith9;host=sferic-dev.eol.ucar.edu",
#                       "zithview", "look-999", { RaiseError=>1} ) ||
#                  die( "Unable to connect to database" );
  # ------------------------------------------------------------ #

  # Uncomment this section if using the live database on Farskol. #
  return DBI->connect( "DBI:mysql:database=zith9;host=farskol.eol.ucar.edu",
                       "zithview", "look-999", { RaiseError=>1} ) ||
                  die( "Unable to connect to database" );
  # ------------------------------------------------------------- #
}
