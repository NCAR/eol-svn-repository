#! /usr/bin/perl -w
##-----------------------------------------------------------------------------
# Script to insert datasets into zith9 with the help of setup
# files to facilitate automated data loading.
#
# Janine Aquino 6/18/2012
#
# Written to grab fields directly from mysql tables rather than hardcode
# them, EXCEPT:
# # WARNING #
# This assumes that the table project_xlink contains the fields
# project_id and xlink_id and the table xlink contains the field id
# whick corresponds to xlink_id.
#
# Used g2n conversion scripts written by Sean Stroble as a starting point,
# then made extensive modification.
#
# Updated 3/25/2021 for changes in database authentication protocols. Also
# cleaned up formatting and added comments.
# 
# Updated 8/20/2021 to separate insert_project and insert_dataset.
#
##-----------------------------------------------------------------------------
my $libdir;
my $scriptsdir;
BEGIN
{
    $libdir = $ENV{"MYSQL_DIR"};
    if (!defined($libdir)) {
       $libdir = "/net/work/lib/perl/mysql";
    }
    $scriptsdir = $ENV{"SCRIPTS_DIR"};
    if (!defined($scriptsdir)) {
       $scriptsdir = "/net/work/bin/scripts/insert";
    }
}

use strict;
# Use deployed copy of perl mysql scripts to work with production database;
use lib $libdir;
use MySqlDatabase;
use lib $scriptsdir;
use ReadConfig;
my $config = ReadConfig->new();

my $msg = "";  # String to contain error messages
my $options = 0;
my $dataset_file = 0;  # Name of YAML file with dataset info
my $records_to_commit = 0;  # Flag to indicate we have inserted records.

# Usage statement
sub usage {
    my @ARGV = shift;
    print "Usage: $0 [-o] [-dev] add_dataset=dataset \n";
    print "\t -o \t Output the possible options for use in the setup files\n";
    print "\t\t and exit. Not pretty, but informative...\n";
    print "\t -dev \t For testing, commits to data.dev\n";
    print "\t\t Example: \"insert_dataset -o add_dataset=PMS2D.yml\n";
    exit(1);
}

if ($#ARGV == -1) #no options, only program name
{
    usage(@ARGV);
}

my $group = 'loaddata.py';  # Default group, production mode
# Read in the command line args, and call subroutines to do the work
foreach my $arg (@ARGV) {
    if ( $arg eq "-o") {
        # Don't do dataset loading, just print options for setup files
        $options = 1;
    }
    elsif ( $arg eq "-dev") {
        # Change group to development mode. Commit to data.dev
        print "\nDEVELOPMENT MODE: Datasets will be loaded to data.dev\n\n";
        $group = 'loaddata.py-dev';
    } 
    elsif ($arg =~ /add_dataset=(.*)/) {
        unless (-e $1) { die "$1 does not exist!\n"; }
        $dataset_file = $1
    } else {
        # Catch invalid command line options
        print "\n WARNING: Invalid command line option ".$arg."\n\n";
        usage(@ARGV);
        exit(1);
    }
}

# Catch if user didn't set add_dataset.
if ($dataset_file eq 0 and not $options) {
    print " Please set filename using add_dataset command\n";
    print " line option\n\n";
    usage(@ARGV);
    exit(1);
}

# Connect to database
my $database = MySqlDatabase->new(undef,undef,undef,'zith9',undef,undef,$group);
$msg = $database->connect();
if ($msg ne "") {
    print "\n\n$msg";
    exit(1);
}

# Add a new dataset if requested
if ($options) {
    print "\nDATASET OPTIONS\n";
    print   "-----------------\n";
}

if ($options or $dataset_file) {
    $msg = adddataset($database, $dataset_file, $options);
    if ($msg ne "") {  # Catch errors
        print "Message: $msg\n";
        $database->rollback();
        exit(1);
    }
}

if (!$options) {
    # Successfully inserted a dataset record
    $records_to_commit = 1;
}

# If this was just an options request, close database and exit;
if ($options) {
    $database->rollback();
    $database->disconnect();
    exit(1);
}

if ($group eq 'loaddata.py') {
    print "\n\n*** Commits are being made to PRODUCTION database ***\n";
} elsif ($group eq 'loaddata.py-dev') {
    print "\n\n*** Commits are being made to DEVELOPMENT database ***\n";
} else {
    # Should never get here, but catch it to be thorough...
    print "\nWARNING: Unknown group $group. This script should only be\n";
    print "\n    used with [loaddata.py] or [loaddata.py-dev] groups. Fix database auth\n";
    print "\n    setting and rerun script.\n";
    exit(1);
}

# If there are no errors, ask user to confirm commit changes to db.
if ($records_to_commit) {
    printf("Please review changes proposed above for accuracy.");
    printf("\nTo commit changes, press Enter.\n");
    printf("To cancel changes, enter any value and press Enter.\n\n");
    printf(">> ");
    my $result = <STDIN>;

    if ($result =~ /^\s*$/) {
        $database->commit()
    } else {
        print "User Selected to Cancel!\n";
        $database->rollback();
    }
}


$database->disconnect();

# End of Main #
##-----------------------------------------------------------------------------
# @signature String adddataset()
# <p> Add a new dataset to the database.</p>
#
# @input $db Database name
# @input $filename Name of YAML file
# @input $options Flag to request printing of all fields in each table
# @output $msg An error message
##-----------------------------------------------------------------------------
sub adddataset {
    my $db = shift;
    my $filename = shift;
    my $options = shift;
    my $msg = "";

    # Read in the attribute/value pairs from the YAML file
    my @ATTR;  # Contains the asttributes from the YAML file
    my @VAL;   # Contains the corresponding values from the YAML file
    if ($filename ne 0) {
        $config->read_config_file($filename,\@ATTR,\@VAL);
        # Get the corresponding project id from the project table and
        # add it to the list of attributes/values.
        get_project_id(\@ATTR,\@VAL);
    }


    my $table = "";
    my @attr = ();
    my @attribute = ();
    my @value = ();
    my %results;

    # Insert dataset, Project Ref, Categories, Platforms, Options
    # (Subset/Browse), etc. ADD NEW TABLES TO THE foreach LOOP HERE AS NEEDED
    # Dataset table must be first so can get dataset_id needed for other tables
    my $dataset_id;
    foreach $table ("dataset", "dataset_project", "dataset_category",
                    "dataset_platform", "codiac_dataset_options",
                    "dataset_version", "dataset_contact") {

        # Handle cases where values need to be in quotes
        if ($table eq "dataset" || $table eq "dataset_version") {
            $database->add_quotes_to_string($table, \@ATTR, \@VAL);
        }
        # Add publish time attribute to tables that require it.
        if ($table eq "dataset_version") {
            push @ATTR, "publish_time";
            push @VAL, "NOW()";
        }

        # Create database insert statement
        $msg = insert_record($database, $table, $options, \@ATTR, \@VAL);
        if ($msg ne "") { return $msg; }  # Error occurred

        # If we are just printing options, go to next table
        if ($options) {next;}

        # After insert dataset, get dataset_id which is needed for other
        # tables. @ATTR and @VAL are all the keys and values for the
        # dataset table.
        if ($table eq "dataset") {$dataset_id = get_dataset_id(\@ATTR,\@VAL);}

        # After insert dataset_version, read id back in and set as
        # current_version_id in dataset table.
        if ($table eq "dataset_version") {
            my $current_version_id;
            (my $msg, $current_version_id) =
                $database->select("dataset_version", "id",
                    "dataset_id=$dataset_id");
            print "UPDATE dataset set current_version_id = ".
                  $current_version_id ." where id=".$dataset_id;
            print "\nUpdate dataset entry:\n";
            print "\tdataset_id: ".$dataset_id."\n";
            print "\tcurrent_version_id: ".$current_version_id."\n";
            print "\n";
            $msg .= $database->update("dataset",
                    "current_version_id = $current_version_id",
                    "id=$dataset_id");
        }
    }

    # GCMD keywords and xlinks are comma separated list of keyword id's.
    # Loop over list here.
    foreach $table ("dataset_gcmd_science_keyword", "dataset_xlink") {
    my @id_list = ();
    my $i;
    my $id_name = "";
    if ($table eq "dataset_gcmd_science_keyword") {
        $id_name = "gcmd_science_keyword_id";
    } elsif ($table eq "dataset_xlink") {
        $id_name = "xlink_id";
    }

    for ($i = 0; $i <= $#ATTR; $i++) {
        if ($ATTR[$i] eq $id_name) {
            @id_list = split(',', $VAL[$i]);
            last;
        }
    }
    # check if found attribute gcmd_science_keyword_id or xlink and 
    # successfully populated list.
    if (@id_list) {
        # $ATTR[$i] and $VAL[$i] contain the gcmd keyword info
        for (my $id = 0; $id <= $#id_list; $id++) {
            # Replace gcmd value or xlink value with each value in list sequentially
            $VAL[$i] = $id_list[$id];
            # ...and create an insert statement for that keyword or xlink
            $msg = insert_record($database, $table, $options, \@ATTR, \@VAL);
            if ($msg ne "") { return $msg; }  # Error occurred
        }
    } else {
        # Still print out options if requested
        if ($options) {
            $msg = insert_record($database, $table, $options, \@ATTR, \@VAL);
            if ($msg ne "") { return $msg; }  # Error occurred
        }
    }
    }

    #Add browsing (if specified)
    $table = "codiac_dataset_plot";
    $msg = insert_record($database, $table, $options, \@ATTR, \@VAL);
    if ($msg ne "") { return $msg; }  # Error occurred

    #Add Dataset Ref (If Specified)
    $table = "dataset_reference";
    $msg = insert_record($database, $table, $options, \@ATTR, \@VAL);
    if ($msg ne "") { return $msg; }  # Error occurred

    #Add secondary, etc contacts  (if specified)
    $table = "dataset_contact";
    $msg = insert_record($database, $table, $options, \@ATTR, \@VAL);
    if ($msg ne "") { return $msg; }  # Error occurred

    return $msg;
}
##-----------------------------------------------------------------------------
# @signature String get_dataset_id
#
# <p>zith9 uses database-generated keys. For the 'dataset' table the id
# is stored in the field 'archive_ident'.  Get 'archive_ident' from the
# 'dataset' table for the record passed in on the command line as arrays
# of keys and values. Return the archive_ident as $dataset_id.</p>
#
# @input @_ Variables passed to subroutine as array. First var is $_[0], etc.
# @input $_[0] keys from the dataset table
# @input $_[1] values from the dataset table
#
# @output $dataset_id 
##-----------------------------------------------------------------------------
sub get_dataset_id {
    my $table = "dataset";
    my $key = "archive_ident";
    (my $msg, my $dataset_id) =
            select_db_key($table, $key, \@{ $_[0] }, \@{ $_[1] });
    if ($msg ne "") {
        print "\n\n$msg";
        exit(1);
    }
    # When -o option in place, dataset_id will be null which causes problems
    # later, so initialize here.
    if (!defined $dataset_id) {$dataset_id="";}
    # Add archive_ident as new field dataset_id at beginning of array
    # of fields from 'dataset' table.
    unshift @{ $_[0] }, "dataset_id";
    # Add value associated with archive_ident key at beginning of array
    # of fields from 'dataset' table.
    unshift @{ $_[1] }, $config->ProcAttr("dataset_id", $dataset_id);

    return $dataset_id;
}
##-----------------------------------------------------------------------------
# @signature Void get_project_id
#
# <p>zith9 uses database-generated keys which are stored in the 'id' field.
# Get id from project table.</p>
#
# @input @_ Variables passed to subroutine as array. First var is $_[0], etc
# @input $_[0] keys from the dataset table
# @input $_[1] values from the dataset table
# @output @_ Modifies variables passed to subroutine as array.
##-----------------------------------------------------------------------------
sub get_project_id {
    my $table = "project";
    my $key = "name";
    (my $msg, my $project_id) =
        select_db_key($table, $key, \@{ $_[0] }, \@{ $_[1] });
    if ($msg ne "") {
        print "\n\n$msg";
        exit(1);
    }
    # Add 'project_id' key to end of keys array
    push @{ $_[0] }, "project_id";
    # Add value associated with 'project_id' key to end of values array.
    push @{ $_[1] }, $config->ProcAttr("project_id", $project_id);
}
##-----------------------------------------------------------------------------
# @signature (String, String) select_db_key
#
# <p>Get id for a single record in a table. Use key/value arrays passed in
# to identify desired record by matching key passed in and retrieving value.
# SELECT id from $table where key = value</p>
#
# @input $table Database table to query
# @input $key Key for which to return value
# @input @_ Variables passed to subroutine as array.
# @input $_[0] keys from the dataset table
# @input $_[1] values from the dataset table
# @output $msg  String containing error message from database command
# @output $id[0] String containing value of id 
##-----------------------------------------------------------------------------
sub select_db_key {
    my $table = shift;
    my $key = shift;
    my @ATTR = @{ $_[0] };
    my @VAL = @{ $_[1] };
    my $val;
    my @attr = ();
    push @attr, $key;  # Add key to a new array

    foreach (@attr) {  # loop through keys, so just $key
        $a = $_;
        # Find $key in keys from table and get $value for this record.
        for (my $i = 0; $i <= $#ATTR; $i++) {
            if ($a eq $ATTR[$i]) { $val = $VAL[$i]; }
        }
    }
    # Get 'id' from table for record where $key equals value retrieved from
    # record array passed in to this function.
    # "select 'id' from table where $key = $value"
    my $tests = "$key = $val";
    ($msg, my @id) = $database->select($table,"id",$tests);
    if ($msg ne "") {
        print "\n\n$msg";
        exit(1);
    }
    if (not @id) {
        print "Could not find id for ".$tests." in database table '".$table."'\n";
        print "Are you sure ".$val." is defined in '".$table."'\n";
        exit(1);
    }

    # Return record 'id' and any error messages
    return ($msg, $id[0]);
}
##-----------------------------------------------------------------------------
# @signature String insert_record
#
# Insert a record into a database table
#
# @input $database database name (zith9)
# @input $table database table name
# @input $options
# @input @_ Variables passed to subroutine as array.
# @input $_[0] keys from the dataset table
# @input $_[1] values from the dataset table
# @input $_[2] fields from the dataset table, retrieved if no YAML file given
# @output
##-----------------------------------------------------------------------------
sub insert_record {
    my $database = shift;
    my $table = shift;
    my $option = shift;
    my @ATTR = @{ $_[0] };
    my @VAL = @{ $_[1] };

    my $msg= "";
    my %results;
    my @attribute = ();
    my @value = ();

    # Return all the fields (columns) from the table, in $results{"name"}
    ($msg, %results) = $database->selectFull($table,'*');
    if ($msg ne "") {
        print "\n\n$msg";
        exit(1);
    }

    # If user just wants to see fields in table, return the list here.
    if ($option) {
        print "$table\n";
        foreach ( @{$results{"name"}} ) {print "\t".$_."\n";}
        return $msg;
    }

    # Loop through the column names
    foreach (@{$results{"name"}}) {
        $a = $_;

        # Loop through the fields in the record we are going to insert
        for (my $i = 0; $i <= $#ATTR; $i++) {
            # Loaddata adds a marker to identify database for some parameters.
            # We want the codiac ones, so remove that here so they will match
            # database fields. Note that fields with _dts will not match and
            # not get used, by design.
            $ATTR[$i] =~ s/_codiac$//;#, $ATTR[$i];

            # Each table in the database contains a subset of the fields in
            # our complete record. If our field matches a field (column) in
            # the database, add it to the list of fields we will insert.
            if ($a eq $ATTR[$i]) {
                push @attribute, $ATTR[$i]; push @value, $VAL[$i];
            }
            #exceptions/inconsistencies
            if ($a eq "project_name" && $ATTR[$i] eq "name") {
                push @attribute, "project_name"; push @value, $VAL[$i];
            }
        }
    }

    # If we didn't match anything...
    if (scalar(@attribute) == 0) {return "";}

    # If we only found one parameter to insert to a table, it will be the
    # dataset_id, and we don't have a complete entry, so bail.
    if ((scalar(@attribute) == 1) && ($attribute[0] eq "dataset_id")) {
        print "Skip $table: only dataset_id defined for $table\n";
        return "";
    }

    # Let the user see the insert command we are about to send to the database,
    # and output a user-friendly table of keys and values we are inserting.
    # These output should be reviewed by the user before they approve the
    # insertion.
    print "INSERT INTO $table(" . join(',', @attribute) . ") VALUES(" .
           join(',', @value) . ")\n";
    print "\nNew $table entry:\n";
    for (my $i = 0; $i < scalar(@attribute); $i++) {
        print "\t".$attribute[$i].": ".$value[$i]."\n";
    }
    print "\n";

    # Send the insert command to the database. Won't be official until the 
    # user confirms and the script sends a commit.
    $msg .= $database->insert($table,join(',', @attribute),join(',', @value));
    if ($msg ne "") {
        print "\n\n$msg";
        exit(1);
    }

    return $msg;
}
##-----------------------------------------------------------------------------
