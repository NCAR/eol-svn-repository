#! /usr/bin/perl -w

#--------------------------------------------------------------------------------
# create_DBcmds.pl
#
# This software generates the SQL commands to apply pre-determined GCMD keywords
# to specified netCDF datasets.
#
# This Perl script tool is the third step in auto generating GCMD:
#  1. Run determine_GCMD.pl to generate *.dataTypes and All_uniq_data_types_*_parm.txt
#  files.
#
#  2. The most knowledgable science person/data manager then adds GCMD keywords
#  to the end of the parm lines (after the xxx) in file All_uniq_data_types_*_parm.txt.
#
#  3. Run create_DBcmds.pl with All_uniq_data_types_*_parm.txt with GCMD keywords
#  to generate (by dataset) the SQL commands to apply to each dataset (*.GCMDcmd).
#
#
# For info on the determine_GCMD.pl software, please that see the header on
#    that code. Here's a short summary on determine_GCMD.pl....
#    The determine_GCMD.pl software creates the All_uniq_data_types_*_parm.txt 
#    output file. The most knowledgable science person/data manager then adds
#    GCMD keywords to the end of the parm lines (after the xxx) that are to be
#    applied for that parameter.  That updated All_uniq_data_types_*_parm.txt
#    file is an input to this create_DBcmds.pl software. determine_GCMD.pl will
#    only work on netCDF files (*.nc or *.cdf) and the first seven chars of the
#    input netCDF files needs to be the CODIAC/Dataset ID (e.g., 534-001).
#
# Execute: 
#    create_DBcmds.pl <input_data_dir> <output_dir> 
#
# Examples: 
#    create_DBcmds.pl ../input_data ../output_data
#
# Input: 
#    <input_data_dir> - directory where *.dataTypes AND All_uniq_data_types_*_parm.txt
#    files for each dataset can be found. This is typically the output directory for the 
#    determine_GCMD.pl program.
#
#    This software also requires the following input files in the same dir as this software:
#       1. all_datasets_id_archive_ident.txt - File relating dataset ID to CODIAC/ZINC internal DB ID.
#       2. all_gcmd_id_uuid.txt - File relating GCMD keywords (as set by sci staff) to GCMD number.
#
# Output: 
#    <output_data_dir> - The location where the *.GCMDcmd files will be located (e.g.,
#    105-004_RF07.20071130.155800_203700.PNI.nc.GMCDcmd, 218-001_RF02.cdf.dataTypes.GCMDcmd, 
#    etc.)
#
# Notes and Assumptions:
#
# 1. The user should search for HARDCODED, ASSUMPTIONS, BEWARE, WARNING, and ERROR in this code. 
#    The user should also search for "exit" in this code so that they know all the possible
#    places/reasons why this code will stop executing.
#
# 2. ASSUMPTION: That the *.dataTypes and All_uniq_data_types_*_parm.txt files exist
#    in the <input_data_dir>.
#
# 3. ASSUMPTION: That the <output_dir> exists.
#
#
# Created: L. Cully Feruary 2020
#
# Updates: None.
#
#--------------------------------------------------------------------------------
package create_DBcmds;
use strict;

if (-e "/net/work") {
    use lib "/net/work/lib/perl/Utilities";
} else {
    use lib "/work/lib/perl/Utilities";
}


my $debug  = 1; # BEWARE: Generates output to screen
my $debug2 = 0; # BEWARE: Generates output to screen

my $TotalFilesProcessed = 0;
my $OutputRec = 0;
my $parm;

printf "\ncreate_DBcmds.pl began on ";print scalar localtime;printf "\n\n";
&main();
printf "\ncreate_DBcmds.pl ended on ";print scalar localtime;printf "\n";


#--------------------------------------------------------------
# void main()
# Run the scripts to determine uniq set of netCDF data_types
# in all files so they can be translated by science staff into
# GCMD keywords.
#--------------------------------------------------------------
sub main 
   {
   if ($debug) {print "Enter Main:: length ARGV = $#ARGV,  ARGV() = @ARGV\n";}

   if ($#ARGV < 1)
      { 
      print "Incorrect number of command line arguments!\n ARGV = @ARGV\n";
      print "Usage: create_DBcmds.pl <input_dir> <output_dir>\n";
      exit(1);
      }

   my $INPUT_netCDF_DIR  = $ARGV[0];
   if ($debug) {print "INPUT_netCDF_DIR = $INPUT_netCDF_DIR \n";}

   my $OUTPUT_DIR  = $ARGV[1];
   if ($debug) {print "OUTPUT_DIR = $OUTPUT_DIR \n";}

   #---------------------------------------------------------------
   # Read in the list of dataTypes files to process (*.dataTypes).
   #---------------------------------------------------------------
#   printf "Opening INPUT_netCDF_DIR:: $INPUT_netCDF_DIR\n";
#   opendir(my $INPUT_DIR, $INPUT_netCDF_DIR) or die("Cannot open INPUT_netCDF_DIR\n");
#   my @files = grep(/\.dataTypes$/,readdir($INPUT_DIR));      # HARDCODED
#   closedir($INPUT_DIR);

   #----------------------------------------------------
   # Read in info from file that relates GCMD IDs to
   # UUID's. These next files are assumed to be located
   # in same dir as this s/w.
   #---------------------------------------------------
   my $input_file = "./all_gcmd_id_uuid.txt";  # HARDCODED
   print "input_file = $input_file\n";

   my $INPUT_GCMD_RELATION_FILE;

   open($INPUT_GCMD_RELATION_FILE,"<", $input_file) or die("Can't open $input_file for reading\n");

   my @lines = <$INPUT_GCMD_RELATION_FILE>;
   my $number_lines_in_file = $#lines+1;
   my %Input_UUID_GCMDID = ();  # Clear Hash

   print "Read into Hash the info from INPUT_GCMD_RELATION_FILE. File has $number_lines_in_file lines.\n";

   foreach my $line (@lines)
      {
      chomp ($line); #remove return \n
      if ($debug2) {print "\nUUID vs GCMD ID RELATION FILE Line: zzz $line zzz\n";}

      my @record = split (/\|/, $line);
      my $key_ID = trim($record[1]);  # This is the UUID associated with GCMD keywords
      my $DB_GCMD_ID = trim($record[0]);

      if ($debug2) {print "UUID key_ID = $key_ID; DB_GCMD_ID = zzz $DB_GCMD_ID zzz\n";}

      $Input_UUID_GCMDID{$key_ID} = $DB_GCMD_ID;
      }

   if ($debug)
      {
      print "\n*****Input Hash UUID vs GCMD IDs *****\n";
      print "\nInput_UUID_GCMDID Hash Contents::\n   \n";
      foreach my $key (sort keys %Input_UUID_GCMDID) 
         {
         print "$key relates to $Input_UUID_GCMDID{$key}\n";
         }
      }


   #----------------------------------------------------
   # Read in info from file that relates datasetID to
   # DB internal ID... aka archive Ident.
   #----------------------------------------------------
   $input_file = "./all_datasets_id_archive_ident.txt";
   print "\ninput_file = $input_file\n";

   my $INPUT_DATASET_ID_RELATION_FILE;

   open($INPUT_DATASET_ID_RELATION_FILE,"<", $input_file) or die("Can't open $input_file for reading\n");

   @lines = <$INPUT_DATASET_ID_RELATION_FILE>;
   $number_lines_in_file = $#lines+1;
   my %Input_DatasetID_archID = ();  # Clear Hash

   print "Read into Hash the info from INPUT_DATASET_ID_RELATION_FILE. File has $number_lines_in_file lines.\n";

   foreach my $line (@lines)
      {
      chomp ($line); #remove return \n
      if ($debug2) {print "\nDATASET ID RELATION FILE Line: zzz $line zzz\n";}

      my @record = split (/\|/, $line);  # Split on vertial bar and add to hash.
                                         # DatasetID will be the hash key.
      my $key_ID = trim($record[1]);
      my $archID = trim($record[0]);

      if ($debug2) {print "DatasetID key_ID = $key_ID; archID = zzz $archID zzz\n";}

      $Input_DatasetID_archID{$key_ID} = $archID;
      }

   if ($debug)
      {
      print "\n*****Input Hash DatasetIDs vs Archive Idents *****\n";
      print "\nInput_DatasetID_archID Hash Contents::\n   \n";
      foreach my $key (sort keys %Input_DatasetID_archID)
         {
         print "$key relates to $Input_DatasetID_archID{$key}\n";
         }
      }

   #------------------------------------------------------
   # Read in the file created by sci/DM staff that relates
   # specific parms/variables to GCMD keywords.
   #------------------------------------------------------
   $input_file = "./gcmd_lrt_c130.txt"; # HARDCODED - FIX THIS!!!!
   print "\ninput_file = $input_file\n";

   my $INPUT_PARM_MATCH_GCMD_FILE;

   open($INPUT_PARM_MATCH_GCMD_FILE,"<", $input_file) or die("Can't open $input_file for reading\n");

   @lines = <$INPUT_PARM_MATCH_GCMD_FILE>;
   $number_lines_in_file = $#lines+1;
   my %Input_parm_match_GCMD = ();  # Clear Hash

   print "Read into Hash the info from INPUT_PARM_MATCH_GCMD_FILE. File has $number_lines_in_file lines.\n";


   my $parm_keyword_string = ""; # This is a string of all the translated
                                 # GCMD keywords for a particular parm/variable
                                 # separated by commas. This string is used
                                 # to form the final SQL command. See sample
                                 # in comment above. This string would be
                                 # "1956,405,404,415,3034,413,479,392,1947,1942,623,1139,3069,433".
   foreach my $line (@lines)
      {
      chomp ($line); #remove return \n
      if ($debug) {print "\nPARM Match GCMD FILE Line: zzz $line zzz\n";}


      # Pick out the parm/variable name to match with GCMD keywords
      my @record = split (/xxx/, $line);           # HARDCODED as 'xxx'
      my @record_tab = split (/	/, $record[0]);    # HARDCODED as a tab
      $parm = $record_tab[0];

      if ($debug) {print "parm = zzz $parm zzz\n";}

      # Pick out the GCMD "code number" to match with those in hash table
      my @record_yyy = split (/yyy/, $record[1]);  # HARDCODED as 'yyy'
      my $number_GCMD = $#record_yyy+1;

      if ($debug) {print "\nrecord[1]: zzz $record[1] zzz\n";}
      if ($debug) {print "\nParm: $parm has $number_GCMD GCMD keywords.\n";}

####      if ($debug && ( $number_GCMD > 1)) {print "\nArray record_yyy[]:\n zzz $record_yyy[0] zzz\n zzz $record_yyy[1] zzz\n zzz $record_yyy[2]\n zzz\n";}

      my $char = "\",";
      my $string = trim($record[1]);
      if ($debug) {print "\nchar = zzz $char zzz  string: zzz $string zzz\n";}

      # -----------------------------------------------------------------------
      # Some parm lines may only have 1 GCMD keyword so must detech that versus
      # either empty or bunch of tabs at end of lines.
      #
      # -----------------------------------------------------------------------
      # -----------------------------------------------------------------------
      # From CBS: Here is the example query for doing things "the other way around."
      #
      # INSERT IGNORE INTO dataset_gcmd_science_keyword (dataset_id, gcmd_science_keyword_id) 
      # SELECT 122, g.id FROM gcmd_science_keyword g WHERE g.id IN (1956,405,404,415,3034,413,
      #      479,392,1947,1942,623,1139,3069,433);
      #
      # In this example, the 122 is the dataset ID (it corresponds to hidden test 
      # dataset 999.98) and the list of IDs in parentheses (1956,405,404,415,3034,
      # 413,479,392,1947,1942,623,1139,3069,433) are GCMD keyword IDs.
      # -----------------------------------------------------------------------
      my $has_GCMD = 0;  
      if ( $number_GCMD > 1)
         {
         $has_GCMD = 1;
         if ($debug) {print "More than one GCMD keyword. YES GCMD.\n"; }
         } # Has more than one GCMD keyword
      elsif ( (index($string, $char)) != -1 ) 
         { 
         $has_GCMD = 1; 
         if ($debug) {print "Found double quote and comma! YES GCMD.\n"; }
         } # Has at least one GCMD keyword
     

      $parm_keyword_string = ""; 

      if ($has_GCMD)
         {
         foreach my $Gkey (@record_yyy)
           {
           if ($debug) {print "\nGkey = zzz $Gkey zzz\n";}
     
           my @GCMD_keyword = split (/,/, $Gkey); # Split on commas & grab last element to translate

           my $GCMD_code = $GCMD_keyword[$#GCMD_keyword];
           if ($debug) {print "\n(1)GCMD code is zzz $GCMD_code zzz\n";}

           $GCMD_code =~ tr/"//d;  # Remove all the double quotes - at begin/end
           $GCMD_code = trim($GCMD_code);  # Remove all the double quotes - at begin/end

           if ($debug) {print "\n(2)GCMD code is zzz $GCMD_code zzz\n";}

           # Translate the GCMD code into the GCMD number
           if (exists ($Input_UUID_GCMDID{$GCMD_code}) )
              {
              $parm_keyword_string = $Input_UUID_GCMDID{$GCMD_code}.','.$parm_keyword_string;
              if ($debug) {print "\nHASH Translate:: zzz $Input_UUID_GCMDID{$GCMD_code} zzz\n";}
              if ($debug) {print "\nBuilding:: parm_keyword_string = zzz $parm_keyword_string zzz\n";}
              }
           else
              {
              if ($debug) {print "\nSkipping GCMD_code = $GCMD_code NOT FOUND in HASH\n";}
              }
           } # foreach Gkey
        } # Only for parms that have keywords defined at end of line 'tween yyy's
     else
        {
        if ($debug) {print "\n Parm $parm DOES NOT have any GCMD keywords Defined.\n";}
        $parm_keyword_string = ""; 
        }

      $parm_keyword_string = substr ($parm_keyword_string,0,-1);  # cut last comma off

      if ($debug) {print "\nTOTAL:: parm_keyword_string = zzz $parm_keyword_string zzz\n";}
      # Assign the string of GCMD keywords for parm into hash
      $Input_parm_match_GCMD{$parm} = $parm_keyword_string;

      if ($debug) {print "\nAssign:: Input_parm_match_GCMD{$parm} = zzz $parm_keyword_string zzz\n";}

      } # foreach line

   if ($debug)
      {
      print "\n*****Input Hash parms vs GCMD keyword string *****\n";
      print "\nInput_parm_match_GCMD Hash Contents::\n   \n";
      foreach my $key (sort keys %Input_parm_match_GCMD)
         {
         print "$key relates to $Input_parm_match_GCMD{$key}\n";
         }
      }

   #**************************************************************
   #**************************************************************
   # All input and tables now in hashes.
   # Write out sql commands for each file which is by dataset.
   #
   # Process all the *.dataTypes files in the output directory:
   # e.g., 103-004_RF12.20070902.180000_021000.PNI.nc.dataTypes
   #**************************************************************
   #**************************************************************
   printf "Reading list of dataTypes files from OUTPUT_dir: $OUTPUT_DIR\n";
   opendir(my $OUTPUT_DIR, $ARGV[1]) or die("Cannot open OUTPUT_DIR\n");

   my @files = grep(/\.dataTypes$/,readdir($OUTPUT_DIR));      # HARDCODED
   if ($debug2) {print "dataTypes files: @files\n";}

###   closedir($OUTPUT_DIR);

   #-----------------------------------------------------------------
   # Process every dataTypes file (*.dataTypes) in the output directory.
   # This is the output from the determine*.pl software.
   # Create the matching *.gcmd output file in that same output dir.
   # The dataTypes files contains a uniq set of parms found in a
   # specific dataset. The dataset ID is in the first few chars of
   # the file name. Generate the SQL commands to apply to that dataset.
   #
   # INSERT IGNORE INTO dataset_gcmd_science_keyword (dataset_id, gcmd_science_keyword_id)
   # SELECT 122, g.id FROM gcmd_science_keyword g WHERE g.id IN (1956,405,404,415,3034,413,
   #      479,392,1947,1942,623,1139,3069,433);
   #
   # In this example, the 122 is the dataset ID (it corresponds to hidden test
   # dataset 999.98) and the list of IDs in parentheses (1956,405,404,415,3034,
   # 413,479,392,1947,1942,623,1139,3069,433) are GCMD keyword IDs.
   #
   #-----------------------------------------------------------------
   foreach my $file (sort(@files))
      {
      #----------------------------------------------------------
      # Pick dataset ID number out of file name e.g., 103.004 for
      # file 103-004_RF12.20070902.180000_021000.PNI.nc.dataTypes
      #----------------------------------------------------------
      my @file_parts = split (/_/, $file);  # HARDCODED as underscore
      my $ID = $file_parts[0];  # 103-004   

      if ($debug) {print "Dataset ID = zzz $ID zzz\n";}
      $ID =~ s/\-/\./;
      if ($debug) {print "(2)Dataset ID = zzz $ID zzz\n";}

      my $archIdent = " ";
      $archIdent = $Input_DatasetID_archID{$ID}; # Relate datasetID to archIdent for SQL command.
      if ($debug) {print "archIdent = zzz $archIdent zzz\n";}

      #--------------------------------------------------------------------------
      # Open the input file e.g.,103-004_RF12.20070902.180000_021000.PNI.nc.dataTypes
      # that lists are uniq parms for that dataset. Read each line/parm and find the
      # associated GCMD keyword(s). Create a string of all those keywords and then
      # write out the SQL command for that parm into output file for that dataset.
      # E.g.,103-004_RF12.20070902.180000_021000.PNI.nc.gcmd will list all the SQL
      # commands that need to be applied to dataset 103.004.
      #--------------------------------------------------------------------------
#NOW HERE
      @file_parts = split (/dataTypes/, $file);  # HARDCODED

      # Open the output file that will contain all the SQL GCMD commands for that dataset.
      my $SQLfile = $ARGV[1]."/".$file_parts[0]."gcmd";
      if ($debug) {print "SQLfile = zzz $SQLfile zzz\n";}

      my $INPUT_DATASET_PARMS_FILE;
      my $OUTPUT_DATASET_SQL_FILE;

      print "Open Input dataTypes and output gcmd files. Add SQL cmds.  \n";
      open($OUTPUT_DATASET_SQL_FILE,">", $SQLfile) or die("Can't open $SQLfile for writing\n");

      my $datatypes_file = $ARGV[1]."/".$file;
      # Open the input file that has one parm per line for that specific dataset.
      open($INPUT_DATASET_PARMS_FILE,"<", $datatypes_file) or die("Can't open $datatypes_file for reading\n");

      my @PARM_lines = <$INPUT_DATASET_PARMS_FILE>;
      print "PARM_lines: @PARM_lines  \n";


      if ($debug) {print "Process each parm line in dataTypes file.\n";}
      foreach my $line (@PARM_lines)
         {
         if ($debug) {print "line = zzz $line zzz\n";}

         # Skip the first header line
         my $loc = index($line, "-------Parms found in File:");  # -1 = hdr line not found so process line
         next if $loc != -1;  # Skip header line equal first line in file

         if ($debug) {print "(89)Processing:: line = zzz $line zzz\n";}
         if ($debug) {print "(99)Processing:: line = zzz $line zzz\n";}

##         chomp ($line); #remove return \n
         if ($debug) {print "(2)PARM Line: zzz $line zzz\n";}

         my @record = split (/\,/, $line); # HARDCODED - 1st element in line is parm
         my $parm = trim($record[0]);  # This the parm/variable
         if ($debug) {print "(4)parm = zzz $parm zzz. Find GCMD keywords to apply!\n";}

         my $GCMD_codes_for_parm = $Input_parm_match_GCMD{$parm};
         if ($debug) {print "(5)parm = zzz $parm zzz. GCMD codes: zzz $GCMD_codes_for_parm zzz\n";}

        ### Do not write sql command if the GCMD code is null!


         #-------------------------------------------------------------------------------------
         # Write SQL command for that parm to *.gcmd file for that dataset.
         # The form of the sql cmd is as follows:
         #
         # INSERT IGNORE INTO dataset_gcmd_science_keyword (dataset_id, gcmd_science_keyword_id) 
         # SELECT 122, g.id FROM gcmd_science_keyword g WHERE g.id IN (1956,405,404,415,3034,
         # 413,479,392,1947,1942,623,1139,3069,433);
         #
         # where 122 is the archIdent/dataset ID and the list of GCMD keyword
         # IDs are in the long list of numbers at the end of the INSERT cmd.
         #
         #--------------------------------------------------------------------------------------
         my $sql_cmd = " ";
         $sql_cmd = sprintf("%s %s %s %s %s", "INSERT IGNORE INTO dataset_gcmd_science_keyword (dataset_id, gcmd_science_keyword_id) SELECT", $archIdent, ", g.id FROM gcmd_science_keyword g WHERE g.id IN (", $GCMD_codes_for_parm, ")");  # HARDCODED
         
         if ($debug2) {print "(6)SQLcmd: zzz $sql_cmd zzz\n";}
exit(22);
         printf $OUTPUT_DATASET_SQL_FILE, $sql_cmd;

         } # foreach line
      } # foreach DataTypes file
   } # main


##------------------------------------------------------------------------------
# @signature String trim(String line)
# <p>Remove all leading and trailing whitespace from the specified String.</p>
#
# @input $line The String to be trimmed.
# @output $line The trimmed String.
##------------------------------------------------------------------------------
sub trim {
    my ($line) = @_;
    return $line if (!defined($line));
    $line =~ s/^\s+//;
    $line =~ s/\s+$//;
    return $line;
} # trim()
