/*--------------------------------------------------------
 * main_qc.c -  Performs Horizontal Quality Control (HQC).
 *   This s/w performs HQC by applying previously
 *   computed variance values and a specified distance
 *   formula to each input parameter for all times and
 *   all stations. The variances are computed by 
 *   executing the compute_sigma program. (See that 
 *   program for more information.) Main_qc.c reads
 *   these variance values and combines these with
 *   specified alpha values to set limits that determine
 *   whether each input value is good (G), dubious (D), or 
 *   unlikely (B). 
 *
 *   The user also specifies the distance function and
 *   the maximum area of influence used during HQC. At any
 *   particular time, this function is used to compute
 *   the distances between all stations at that time.
 *   Currently to allow maximum flexibility, this
 *   s/w computes and applies these distances continually
 *   as data is read and processed. If all stations
 *   are fixed in location, then it is possible to do
 *   these computations only once. These values could
 *   be retained at the expense of using (potentially)
 *   lots of space. Experience may show, however, that
 *   it is wise to pay the price of recomputing these
 *   distances each time period. It is already known
 *   that stations come and go (and even move) in
 *   the data as time passes. This section of the process
 *   may need to be modified/changed if processing time is
 *   too large.
 *       
 * Assumptions:
 *  - Assumes specific format for sigma squared file
 *    names: yyyyjjjhhmm.sig where yyyy is  the year,
 *    jjj is the julian date, hh is the hour,
 *    and mm is the minute. Name indicates date and time
 *    that variances included in file are valid.
 *  - Assumes specific format for user specified input file.
 *  - Input data is in QCF format and sorted by date/time.
 *    These should be the exact same files that compute_sigmasq
 *    file used to compute the sigmasq (variance) values.
 *  - Expects suffix for input file names to be .0qc. This
 *    is currently hardcoded. Can change and recompile.
 *
 * Input:
 *    User must indicate name of QC input control file when
 *    executing this program. This QC input control file
 *    contains several input values, limits, dates,
 *    etc. required by the horizontal QC program. The format
 *    for this input file is as follows:
 *
 *          Definition                        (var) (type)
 *  -----------------------------------------------------------------
 *  Line 1: Distance fn method                (pmethod) (float)
 *  Line 2: Area of Influence in km           (1/min_weight) (float)
 *  Line 3: Data Frequency                    (data_freq) (integer)
 *  Line 4: Current year of data              (current_yr) (YYYY string)
 *  Line 5: First day of Project              (proj_begin_date) (YYMMDD string)
 *  Line 6: First day to QC/compute variance  (begin_date) (YYMMDD string)
 *  Line 7: Last day to QC/compute variance   (end_date) (YYMMDD string)
 *  Line 8: Input file pathname               (pathname) (string)
 *  Line 9: Sigma file pathname               (sigpathname) (string)
 *  Line 10:Precip Unlikely (B) Gross Limit   (bmax) (float)
 *  Line 11:Precip Dubious Gross Limit        (dmin) (float)
 *  Line 12: Alpha Unlikely & Dubious for stn pres      (two floats)
 *  Line 13: Alpha Unlikely & Dubious for sea lvl pres  (two floats)
 *  Line 14: Alpha Unlikely & Dubious for calc slp      (two floats)
 *  Line 15: Alpha Unlikely & Dubious for temp          (two floats)
 *  Line 16: Alpha Unlikely & Dubious for dew point     (two floats)
 *  Line 17: Alpha Unlikely & Dubious for wind speed    (two floats)
 *  Line 18: Alpha Unlikely & Dubious for wind dir      (two floats)
 *
 * This program also expects sigma_sq files as input. These sigma_sq
 * or variance files have file names of the form:
 *                   yyyyjjjhhmm.sig
 *
 *    where yyyy is year, jjj is julian date, hh is hour, mm is
 *    minute for which the contained sigmasq (variance) values
 *    are valid. And will be located in the directory specified
 *    as the output directory in the QC input control file. 
 *    The form of all output variance files is:
 *
 *          Definition                        (var) (type)
 *  -----------------------------------------------------------------
 *  Line 1: Number of stations at this time   (numstns) (int)
 *  Line 2->xx: Internal ID Stn ID            (i, stn_list[i]) (int, string)
 *  Line xx+1: Comment line                   ("stn_no parm_no  sigma value")
 *  Line xx+2: InternalID  Parm# Variance     (i, j, sigma_sq[i][j]) (int, int, float)
 *
 * (Line xx+2 is repeated for each variance for parameter (0-6 (j)) for each stn.)
 *
 *  Example of variance file:
 *   1
 *     0 E02
 *   stn_no parm_no  sigma value
 *       0     0 33.714584
 *       0     1 33.271523
 *       0     2 67.128426
 *       0     3 29.454615
 *       0     4 38.043491
 *       0     5 3.950475
 *       0     6 13018.718750
 *  (end example)
 *
 * Output:
 *   Quality Controlled QCF files. (*.qcf)
 *
 * 10 Dec 94 lec
 *   Created.
 * 06/08 Jun 95 lec
 *   Upgrade s/w with mods specified by scientific staff.
 *   These upgrades include allowing different alpha
 *   values for each parameter AND changing the logical
 *   quality control checks performed at the end of this
 *   program.
 * 11 Sep 95 lec
 *   Updated s/w to accept name of QC input file as
 *   line input.
 *-------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>

#include "local.h"
#include "process_qcfrec.h"
#include "qcfrec.h"
#include "gQC.h"
#include "date.h"

/*-------------------------------------------------------
 * Set DEBUG to 1 for debug type output to screen
 * during any run. Set to 0 to prevent debug output.
 *
 * Set QC_STNPRS to 1 to allow quality control processing
 * to occur for station pressure. Typically this is not
 * done because we use the Calculated Sea Level or Sea 
 * Level pressure QC flags to set the station pressure
 * QC flag. The user may still set this flag to 1 to
 * allow Horizontal QC to be applied to station pressure.
 * Note that the logical check that propagates the sea
 * level QC flags will override the station pressure
 * QC flag set by HQC.
 *-------------------------------------------------------*/
#define  DEBUG     1
#define  QC_STNPRS 0 

/* local functions */
#ifdef __STDC__
   int main (int argc, char *argv[]);
#else /*!__STDC__*/
   int main ();
#endif /*__STDC__*/


/*---------------------------------------------------------
 * main() - controls Horizontal Quality Control processing flow.
 *
 * 10 Dec 94 lec
 *   Created.
 *--------------------------------------------------------*/
int main( argc, argv)
int argc;
char *argv[];
   {
   /* local variables */
   char         init_input_file_name[NAMELEN_MAX];
   char         input_file_name[NAMELEN_MAX];
   char         sigma_output_file_name[15] = "\0";
   char         qcf_output_file_name[15] = "\0";

   FILE         *init_input_stream;
   FILE         *input_stream;
   FILE         *sigma_output_stream;
   FILE         *qcf_output_stream;

   char         pathname[NAMELEN_MAX];
   char         sigpathname[NAMELEN_MAX];

   char         uncompress_cmd [NAMELEN_MAX+10];

   QCFREC       *qcfptr;
   QCFREC       *current_qcfptr;

   QCFREC       *qcfptr_array[MAXNUMSTNS];
 
   int          i,ii,j,jj,k,kk,mm,zz,yy,xx,yyy = 0;
   int          data_freq   = 0;
   STRING16     stn_list[MAXNUMSTNS];
   long         stn_no      = -1;
   long         numstns     = 0;
   long         numstns_inp = 0;
   long         index       = 0;
   long         print_order[MAXNUMSTNS];

   int          pmethod;    /* input value - determine weight fn */
   float        min_weight; /* input value - determines area of influence around each stn */

   float        bmax;       /* input value - 'Bad' Gross limit for precip QC. */
   float        dmin;       /* input value - 'Dubious' Gross limit for precip QC. */

   float        alpha0, alpha1;

   float        alpha_sq[NUMQCPARMS][2] = { {0.0,0.0},{0.0,0.0},    /* input values - G,D,B limits */
                                            {0.0,0.0},{0.0,0.0},
                                            {0.0,0.0},{0.0,0.0},
                                            {0.0,0.0} };
   float        A [MAXNUMSTNS][4];
 
   float        theta_o[NUMQCPARMS][MAXNUMSTNS];  /* observations at stns in array A[][] */
   int          numtheta_o[NUMQCPARMS];
 
   double       x,y = 0.0;

   char         current_century_str[3] = "\0\0\0"; /* Upon startup, this should be the */
   int          current_century   = 0;             /* century of the begin_date.       */

   int          current_yr   = 0;
   int          current_hr   = 0;
   int          current_min  = 0;
   int          current_date = 0; /* Julian date */

   char         date[7]      = "\0\0\0\0\0\0\0";
 
   char         proj_begin_date[7] ="\0\0\0\0\0\0\0"; /* Date project began. This is the date
                                                         Compute_sigmasq used to calc variances.
                                                         From "proj_begin_date" to "project_begin_date+
                                                         SIGMA_PERIOD+1", the set of sigma files named
                                                         and dated "project_begin_date+SIGMA_PERIOD"
                                                         are used. After that date each day has
                                                         recomputed variances. */

   char         begin_date[7] ="\0\0\0\0\0\0\0"; /* Input date to begin (QC) processing */
   char         end_date[7]   ="\0\0\0\0\0\0\0"; /* Input date to end processing        */
 
   int          proj_begin_jdate  = 0;           /* Julian date that project begins. input value!! */
   int          begin_jdate       = 0;           /* Julian date that data begins.    input value!! */
   int          end_jdate         = 0;           /* Julian date that data ends.      input value!! */
   int          process_jdate     = 0;           /* Beginning Julian date of current days for which
                                                    sigmasq is being computed. This var increments
                                                    along one day at a time through the complete
                                                    project period or the specified time. It increments
                                                    one day, then sigmasq's are computed for all stns
                                                    and all parameters at all times over the current
                                                    sigma period. These new sigmasq's are valid for
                                                    the date = process_jdate+SIGMA_PERIOD only. The only
                                                    exception to this rule is that the first set of
                                                    sigmasq's computed are used to QC data from day
                                                    1 of project to day = begin_date+SIGMA_PERIOD+1. 
                                                    In other words, if SIGMA_period is 30 days, the
                                                    variances (sigmasq's) that are computed using data
                                                    from the first 30 days are used to QC the first 31
                                                    days of the project. You must use the sigma values
                                                    valid for day 31 to QC the project's first 31 days,
                                                    unless you have data preceding the beginning of the
                                                    project. */


   /* If data rollsover into next year, the data is processed in two chunks. 
      One Chunk ends at end of current_yr. Next (and final) Chunk begins on 01 Jan
      of current_yr+1 and ends on date user requested in input file. */

   int          data_rollsover = 0;   /* Boolean flag indicating if data rollsover
                                         from one year into the next. */
   int          data_to_process = 1;  /* Boolean flag indicating if there is still
                                         data to be processed. */

   char         end_MMDD[5]   = "\0\0\0\0\0"; 
   char         begin_MMDD[5] = "\0\0\0\0\0"; 

   char         last_date_in_yr[7]      = "\0\0\0\0\0\0\0";
   char         first_date_in_nextyr[7] = "\0\0\0\0\0\0\0";

   int          last_julian_day_in_yr   = 0;
   int          first_julian_day_in_nextyr = 0;

   int          saved_end_jdate = 0;
 
 
   /*
    * stn_data    - data from which sigmas are computed.
    * stn_numdata - number of data points in stn_data by parameter.
    * sigma_sq    - variances for each stn and each parameter at a specified time.
    */
   float stn_data[MAXNUMSTNS][NUMQCPARMS][SIGMA_PERIOD];
 
   int   stn_numdata[MAXNUMSTNS][NUMQCPARMS] = {{0,0,0,0,0,0,0},{0,0,0,0,0,0,0},{0,0,0,0,0,0,0},
                                                {0,0,0,0,0,0,0}, {0,0,0,0,0,0,0},{0,0,0,0,0,0,0},
                                                {0,0,0,0,0,0,0}};
 
   float sigma_sq[MAXNUMSTNS][NUMQCPARMS]    = {{0,0,0,0,0,0,0},{0,0,0,0,0,0,0},{0,0,0,0,0,0,0},
                                                {0,0,0,0,0,0,0}, {0,0,0,0,0,0,0},{0,0,0,0,0,0,0},
                                                {0,0,0,0,0,0,0}};

   /*
    * Expect input file name on the command line.
    */
   if (argc != 2)
      {  
      printf ("Usage: main_qc <initialization_input_file>\n");
      exit(1);
      }  

   strcpy (init_input_file_name, argv[1]);

   /*----------------------------------------------------------
    * Initialize from input file. This should be the same
    * file that is used during compute_sigmasq processing.
    *----------------------------------------------------------*/
   printf ("\n---- Horizontal Quality Control ----\n");
   printf ("Processing began on %-s %-s\n", __DATE__, __TIME__);
   printf ("QC Initialization file name (e.g., QCinit.inp): %-s\n", init_input_file_name);
   
   open_file (init_input_file_name, "r", &init_input_stream);

   printf ("\nPARAMETER INITIALIZATION:: \n\n");

   /*-----------------------------------------
    * Read data from input file (QCinit.inp).
    *----------------------------------------*/ 
   fscanf (init_input_stream, "%d", &pmethod);        STRIPLINE(init_input_stream);
   fscanf (init_input_stream, "%f", &min_weight);     STRIPLINE(init_input_stream);
   min_weight = 1.0/min_weight;         /* invert for HQC processing */
   fscanf (init_input_stream, "%d", &data_freq);      STRIPLINE(init_input_stream);
   fscanf (init_input_stream, "%d", &current_yr);     STRIPLINE(init_input_stream); 
   fscanf (init_input_stream, "%s", proj_begin_date); STRIPLINE(init_input_stream);
   proj_begin_date[6] = '\0';
   fscanf (init_input_stream, "%s", begin_date);      STRIPLINE(init_input_stream);
   begin_date[6] = '\0';
   fscanf (init_input_stream, "%s", end_date);        STRIPLINE(init_input_stream);
   end_date[6] = '\0';
   fscanf (init_input_stream, "%s", pathname);        STRIPLINE(init_input_stream);
   fscanf (init_input_stream, "%s", sigpathname);     STRIPLINE(init_input_stream);
   fscanf (init_input_stream, "%f", &bmax);           STRIPLINE(init_input_stream);
   fscanf (init_input_stream, "%f", &dmin);           STRIPLINE(init_input_stream);

   printf ("Distance fn method (pmethod): %d\n", pmethod);
   printf ("Area of Influence in km (1/min_weight): %8.3f\n", 1.0/min_weight); /* print km */
   printf ("Data Frequency (data_freq): %d\n", data_freq);

   sprintf (current_century_str, "%-2d", current_yr);
   current_century = atoi(current_century_str);

   printf ("Current century of data: %d\n", current_century);
   printf ("Current year of data: %d\n", current_yr);
   printf ("First day of Project (proj_begin_date): %-s\n", proj_begin_date);
   printf ("First day to QC (begin_date) : %-s\n", begin_date);
   printf ("Last day to QC (end_date)    : %-s\n", end_date);
   printf ("Input file pathname: %-s\n", pathname);
   printf ("Sigma file pathname: %-s\n\n", sigpathname);
   printf ("Precipitation Gross Limits (Unlikely, Dubious): %f %f\n\n", bmax, dmin);
   printf ("Alpha_sq Indices: 0=stn pres, 1=slp, 2=cslp, 3=temp, 4=dw pt, 5=wnd sp, 6=wnd dir\n");

   /*--------------------------------------------------------
    * Read default bad & dubious alpha limit values for each
    * parameter. Save the square of the alpha values. Squared
    * values are required by Horizontal QC process done in
    * determine_qcflag() function.
    *--------------------------------------------------------*/
   for (yy=0;yy<NUMQCPARMS;yy++)
      {
      fscanf (init_input_stream, "%f %f", &alpha0, &alpha1); 
      STRIPLINE(init_input_stream);
      alpha_sq[yy][0] = alpha0*alpha0;
      alpha_sq[yy][1] = alpha1*alpha1;

      printf ("alpha_sq[%2d][0] = %4.2f alpha_sq[%2d][1] = %4.2f\n",
               yy, alpha_sq[yy][0], yy, alpha_sq[yy][1]);
      }


   /*---------------------------------------------
    * Begin Horizontal Quality Control processing.
    *--------------------------------------------*/
   /*------------------------------- 
    * Convert input dates to Julian    
    *------------------------------*/   
   date_to_julian (proj_begin_date, current_yr, &proj_begin_jdate);
   date_to_julian (begin_date, current_yr, &begin_jdate);
   date_to_julian (end_date, current_yr, &end_jdate);

   /*---------------------------------------------
    * Construct qcfrec pointers then read the data.
    *---------------------------------------------*/
   construct_qcfptr (&qcfptr);
   construct_qcfptr (&current_qcfptr);
 
   for (ii=0;ii<MAXNUMSTNS;ii++)
      {
      construct_qcfptr ( &qcfptr_array[ii]);
      reset_qcfrec( qcfptr_array[ii] );
      print_order[ii] = 0;
      }

   /*------------------------------------------------------------------
    * If end_date is less than begin_date then the data must rollover
    * through the end of the year. To make things simple,
    * process the data in two chunks. Process from begin_date
    * to end of the year, then process from beginning of next year
    * to the end_date. This can probably be handled more gracefully.
    * If there is ever time, this logic can be worked on. Also note
    * that the year will change and the century might change! Remember
    * to increment the current_yr!
    *-----------------------------------------------------------------*/
   data_rollsover = 0;
   data_to_process = 1;

   strncpy (end_MMDD,  &end_date[2],  4);
   end_MMDD[4]  = '\0';
   strncpy (begin_MMDD,&begin_date[2],4);
   begin_MMDD[4] = '\0';

   printf ("Check for EOY rollover - end_MMDD, begin_MMDD:: %-s %-s\n", 
           end_MMDD, begin_MMDD);

   if (atoi(end_MMDD) < atoi(begin_MMDD))
      {
      data_rollsover = 1;
      sprintf (last_date_in_yr, "%-s%-s\0", current_century_str, "1231");
      date_to_julian (last_date_in_yr, current_yr, &last_julian_day_in_yr);

      sprintf (first_date_in_nextyr, "%2d%-s\0", current_century+1, "0101");
      date_to_julian (first_date_in_nextyr, current_yr, &first_julian_day_in_nextyr);

      saved_end_jdate = end_jdate;
      end_jdate = last_julian_day_in_yr;

      printf ("Data rollsover into the next year! data_rollsover = %d\n",data_rollsover);
      printf ("   last_julian_day_in_yr, first_julian_day_in_nextyr: %d %d\n",
              last_julian_day_in_yr, first_julian_day_in_nextyr);
      }


   while (data_to_process)
      {
      printf ("Top of While data_to_process \n");

   /*-----------------------------------------------------------------
    * Do Quality Control processing on all requested data. Read proper
    * sigma file (according to date and time of data being QC'd) and
    * stn_list info.
    *----------------------------------------------------------------*/
   for (current_date=begin_jdate; current_date<=end_jdate; current_date++) 
      {
      /*
       * Form name of input file and open. Assume name of data being QC'd
       * is of the form yyddmm.0qc and the QC'd file will be yyddmm.qcf.
       */
      printf ("\nCurrent julian date is: %d\n", current_date);
exit(1);
      julian_to_date (current_date, current_yr, date);

      sprintf (input_file_name, "%-s%-s.0qc", pathname, date);
      open_file (input_file_name, "r", &input_stream);
      printf ("Open input file: %-s\n", input_file_name);

      sprintf (qcf_output_file_name, "%-s%-s.qcf", pathname, date);
      printf ("Open output file: %-s\n", qcf_output_file_name);
      open_file (qcf_output_file_name, "w", &qcf_output_stream);

      numstns = 0;

      reset_qcfrec( qcfptr );
      read_qcfrec (&input_stream, qcfptr);

      
      /*--------------------------------------------------
       * We assume that the input (*.0qc) files are sorted
       * by date/time.
       *-------------------------------------------------*/
      while (!feof(input_stream))
         {
         current_hr = qcfptr->hour_nom;
         current_min = qcfptr->minute_nom;

         printf ("------GET NEXT TIME: current_hr, current_min: %d %d\n", current_hr, current_min);

         /*---------------------------------------------------
          * Open, read the sigmasq (variance) file which
          * contains the variances for all stns at time
          * t. For the first SIGMA_PERIOD+1 days use the
          * sigmasq's computed during the first SIGMA_PERIOD.
          *---------------------------------------------------*/
         if (current_date <= proj_begin_jdate+SIGMA_PERIOD)
            sprintf (sigma_output_file_name, "%-s%02d%03d%02d%02d.sig",
                     sigpathname, current_yr, proj_begin_jdate+SIGMA_PERIOD,
                     current_hr, current_min);
         else
            sprintf (sigma_output_file_name, "%-s%02d%03d%02d%02d.sig",
                     sigpathname, current_yr, current_date, current_hr, current_min);


         sprintf (uncompress_cmd, "gunzip %-s.gz", sigma_output_file_name);
         printf ("excuting cmd:%-sxxx\n", uncompress_cmd); 
         system (uncompress_cmd);

         open_file (sigma_output_file_name, "r", &sigma_output_stream);
         fscanf (sigma_output_stream, "%ld\n", &numstns_inp);

#if DEBUG
         printf ("numstns_inp: %ld\n", numstns_inp);
#endif

         for (ii=0;ii<numstns_inp;ii++)
            {
            fscanf (sigma_output_stream, "%d %s", &ii, stn_list[ii]);
#if 0
            printf ("stn_list[%d] =  %sxxx\n", ii, stn_list[ii]);
#endif
            }

         STRIPLINE (sigma_output_stream); /* Skip the comment line. */
         STRIPLINE (sigma_output_stream); /* Skip the comment line. */

         while (!feof(sigma_output_stream))
            {
            fscanf (sigma_output_stream, "%d%d", &ii, &kk);
            fscanf (sigma_output_stream, "%f", &sigma_sq[ii][kk]);
            if (feof(sigma_output_stream)) break;
#if 0
            printf ("(read)sigma_sq[%d][%d] = %f\n", ii, kk, sigma_sq[ii][kk]);
#endif
            } /* data in file */
 
         close_file (&sigma_output_stream);

         sprintf (uncompress_cmd, "gzip %-s\0", sigma_output_file_name);
         system (uncompress_cmd);

         numstns = 0;

         for (zz=0;zz<NUMQCPARMS;zz++)
            numtheta_o[zz]= 0;


         for (xx=0;xx<MAXNUMSTNS;xx++)
            {
            A[xx][0] = -999.99; /*latitude*/
            A[xx][1] = -999.99; /*longitude*/
            A[xx][2] = 0.0;     /*weight - generally a function of distance.*/
            A[xx][3] = 0.0;     /*distance*/
            }

         for (xx=0;xx<NUMQCPARMS;xx++)
            for (yyy=0;yyy<MAXNUMSTNS;yyy++)
               theta_o[xx][yyy] = -999.99;       /* reinit to missing! Prevents adding
                                                    in bad values when stn in area of 
                                                    influence, yet data value missing, 
                                                    0.00,etc.*/


         while ( (qcfptr->hour_nom == current_hr) && (qcfptr->minute_nom == current_min))
            {
            /*--------------------------------------------------------------
             * Determine internal stn number from stn_list. Note that at 
             * this point numstns should not be changed by the following fn.
             * May want to check this.
             *--------------------------------------------------------------*/
            stn_no = determine_stn_no(stn_list, &numstns_inp, qcfptr->statn);
            
            /*------------------------------------------------------
             * Retain knowledge of the input order, so can print out
             * in same order...not in stn_no order.
             *-----------------------------------------------------*/
            print_order[numstns] = stn_no;
#if 0
            printf ("qcfptr->statn, stn_no: %-sxxx %d\n", qcfptr->statn, stn_no);
            printf ("qcfptr->lat, lon: %7.2f %7.2f\n", qcfptr->lat, qcfptr->lon);
#endif
            copy_qcfrec (qcfptr_array[stn_no],qcfptr); 
   
            /*-------------------------------------------------------
             * Fill up A's lat/lons and theta_o (Observation) values.
             * Keep track of how many Obs values stored for each
             * parameter in numtheta_o array.
             *------------------------------------------------------*/
            A[stn_no][0] = qcfptr->lat;
            A[stn_no][1] = qcfptr->lon;

#if QC_STNPRS
            /* -- Station Pressure. -- */
            if (qcfptr->staprs >0.00)
               {
               theta_o[stnprs][stn_no] = qcfptr->staprs;
               numtheta_o[stnprs]++;
               }
#endif 
            /* -- Sea Level Pressure. -- */
            if (qcfptr->seaprs >0.00)
               {
               theta_o[slp][stn_no] = qcfptr->seaprs;
               numtheta_o[slp]++;
               }

            /* -- Calculated Sea Level Pressure.  -- */
            if (qcfptr->cmpsea >0.00)
               {
               theta_o[cslp][stn_no] = qcfptr->cmpsea;
               numtheta_o[cslp]++;
               }
 
            /* -- Temperature  -- */
            if (qcfptr->temp >-999.00)
               {
               theta_o[temp][stn_no] = qcfptr->temp;
               numtheta_o[temp]++;
               }
 
            /* -- Dew Point Temperature  -- */
            if (qcfptr->dewpnt >-999.00)
               {
               theta_o[dewpt][stn_no] = qcfptr->dewpnt;
               numtheta_o[dewpt]++;
               }
 
            /* -- Wind Speed  -- */
            if (qcfptr->wndspd >-999.00)
               {
               theta_o[windsp][stn_no] = qcfptr->wndspd;
               numtheta_o[windsp]++;
               }
 
            /* -- Wind Direction -- */
            if (qcfptr->wnddir >-999.00)
               {
               theta_o[winddir][stn_no] = qcfptr->wnddir;
               numtheta_o[winddir]++;
               }

            numstns++;   /* Actually equals the number of recs at this time!!
                            NOTE: Stn nums are NOT necessarily in order.    */

            reset_qcfrec( qcfptr );

            if (feof(input_stream)) break;

            read_qcfrec (&input_stream, qcfptr);
            
            } /* while qcfptr times equal current times.*/

         /*------------------------------------------------------
          * At this point have read in all data for current time.
          *-----------------------------------------------------*/
#if DEBUG
         printf ("Completed filling A now compute qcflag. numstns, numstns_inp: %ld %ld\n", 
                  numstns, numstns_inp);
#endif

         /*-------------------------------------------------------------------------
          * Compute distances and weights only once. They apply for all parameters 
          * at this time at a particular stn. Beware applying to more times, cause 
          * at different times may have different set of stns (or some stns may
          * drop out on some parameters).
          *
          * Distances vary according to location of reference stn. 
          * Loop through stations letting each in turn be the ref stn when
          * QCing that stns data.
          *
          * Do numstns_inp not numstns cause must check all possible stns to see if
          * data read. Using numstns may cause last statns to not get QC'd.
          *------------------------------------------------------------------------*/
         for (mm=0;mm<numstns_inp;mm++)
            {
            copy_qcfrec(current_qcfptr, qcfptr_array[mm]);
   
            /*----------------------------------------------------
             * Don't process blank stns. Not all possible stns may
             * occur at each time. Stations come and go in data.
             *---------------------------------------------------*/
            if (!strncmp(current_qcfptr->statn,"               \0",15)) continue;

            stn_no = determine_stn_no(stn_list, &numstns_inp, current_qcfptr->statn);

#if DEBUG
            printf ("\nCompute dist and weights for Current stn, stn_no: %-s %d<---------------\n", 
                    current_qcfptr->statn,stn_no);
#endif

            /*------------------------------------------------------------
             *  Let current station be the reference station.
             *  Compute distances from ref station to all other 
             *  stations and put in A[,4]. 
             *
             * NOTE: Because of the shape and curvature of the earth, the
             *  ll2xydrv() function will compute potentially different
             *  distances between two stations depending on which is allowed
             *  to be the reference station. It is important to let
             *  the current station be the reference station each
             *  time. Theoretically, when all stns on the surface
             *  are fixed, these computations could be performed 
             *  once and saved. However, since each distance between
             *  any two stations must be computed in both directions,
             *  the storage required to save distances for a large number
             *  of stations could be significant. Here we choose to 
             *  perform the computations each time to allow for maximum
             *  flexiblity in station movement, etc. 
             *
             *  Don't processing against Missing (-999.99) stations.
             *  Must check numstns_inp here, too.
             *-------------------------------------------------------------*/
            for (ii=0;ii<numstns_inp;ii++)
               {
               if (A[ii][0]>-990.00 && A[ii][1] >-990.00)
                  {
                  ll2xydrv( current_qcfptr->lat, current_qcfptr->lon, &x, &y, A[ii][0], A[ii][1]); 
                  A[ii][3]=sqrt(x*x+y*y);                                           /* distance */
#if 0
                  printf ("x, y, A[%d][3]: %lf %lf %f\n", ii, x, y, A[ii][3]); 
#endif
                  }
#if 0
               else
                  printf ("Station (%d) is missing. no lat/lon pair = no distance\n",ii );
#endif
               }
  
            /*---------------------------------------------------
             * Determine "weights" (influence) of other stations.
             * The user selects the method (eqn) used to determine
             * the weight of each station by setting the pmethod
             * input value in the input file.
             *
             * (Ensure dist/weight is 0.0 if lat/lon = -999.99)
             *--------------------------------------------------*/
            weight(A, numstns_inp, pmethod);

            /*-----------------------------------------------------
             * Determine QC flag for all parameters at current stn.
             * Allow s/w to not QC station pressure since this vars
             * QC flag is reset by either Calc Sea Lvl Press or Sea
             * Lvl Press's QC flag.
             *
             * jj - Type of data begin processed. (0=Stn Press,
             *      1=Sea Lvl Press, 2=Calc Sea Lvl Press, 3=Temp,
             *      4=Dew Point, 5=Wind Speed, 6=Wind Direction.)
             *----------------------------------------------------*/
            for (jj=0;jj<NUMQCPARMS;jj++)
               {
#if !QC_STNPRS
/*             if (jj == 0)
                  printf ("Currently NOT QCing station pressure data, only.\n"); */

               if (jj != 0) {    /* Don't process stn pressure data, unless requested. */
#endif
               /*----------------------------------------------------
                * Apply Horizontal Quality Control to each parameter.
                *
                * The user controls the limits which determine whether
                * a value is Good (G), Dubious (D), or Unlikely (B)
                * by setting the alpha input values read from the
                * specified input file. Remember, the user specifies
                * the alpha values which are then squared and passed
                * on to the following function.
                *---------------------------------------------------*/
#if DEBUG
               printf ("Call determine_qcflag. jj = %d\n", jj);
#endif
               if (numtheta_o[jj] >1)
                  determine_qcflag ( A, 
                                     theta_o[jj], 
                                     numstns_inp,
                                     sigma_sq[stn_no][jj],
                                     min_weight, 
                                     alpha_sq, 
                                     jj, 
                                     current_qcfptr);
#if DEBUG
               else
                  printf ("numtheta_o[%d] = %ld. --NO QC FOR stn=%-s\n", 
                           jj, numtheta_o[jj], current_qcfptr->statn);
#endif
   
#if !QC_STNPRS
               } /* QC station pressure only when requested. */
#endif
               } /* for QC all parameters (NUMQCPARMS) (jj)*/

           
            /*--------------------------------------------------------------
             * Extraneous/logical QC checks.
             *--------------------------------------------------------------
             * Gross limit check the precip. Update the flags!
             * This limit check only works properly if data is all at
             * same frequency in the composite. VORTEX data was not this way!
             *
             * B overrides E, but D does NOT. Estimated values are
             * are only reset if found to be bad.
             *
             * Do not gross limit check the precip if the QC flag is any
             * of the following:
             *
             * Missing (M), Not Available (N), Glitch (X), or
             * Exceeds format size (C).
             *--------------------------------------------------------------*/
            if (current_qcfptr->prcflg != 'M' && current_qcfptr->prcflg != 'N' &&
                current_qcfptr->prcflg != 'X' && current_qcfptr->prcflg != 'C')
               {
               if (current_qcfptr->precip < -999.00)
                  current_qcfptr->prcflg = 'M';
               else if (current_qcfptr->precip >= bmax || current_qcfptr->precip< 0.0)
                  current_qcfptr->prcflg = 'B';
               else if (current_qcfptr->precip >= dmin && current_qcfptr->prcflg != 'E')
                  current_qcfptr->prcflg = 'D';
               else
                  if (current_qcfptr->prcflg != 'E') current_qcfptr->prcflg = 'G';
               }



#if DEBUG
            if (current_qcfptr->precip >0.0 && current_qcfptr->prcflg == 'G' &&
                current_qcfptr->clamt1 == 0)
               printf ("LOGICAL: Precip in clear air deteched. Set prcflg = D!!\n");
#endif

            /*-------------------------------------
             * Can't have precip in clear air.
             *------------------------------------*/
            if (current_qcfptr->precip >0.0 && current_qcfptr->prcflg == 'G' &&
                current_qcfptr->clamt1 == 0)
               current_qcfptr->prcflg = 'D';


            /*-----------------------------------------------------
             * If first cloud layer is present then next
             * levels should be Not available instead of Missing.
             * Reset ceiling height flags and cloud amount qc flags.
             *-----------------------------------------------------*/
            if (current_qcfptr->c1flg == 'U' || current_qcfptr->c1flg == 'E')
               {
               if (current_qcfptr->c2flg == 'M')current_qcfptr->c2flg = 'N';
               if (current_qcfptr->c3flg == 'M')current_qcfptr->c3flg = 'N';
               if (current_qcfptr->ca2flg == 'M')current_qcfptr->ca2flg = 'N';
               if (current_qcfptr->ca3flg == 'M')current_qcfptr->ca3flg = 'N';
#if DEBUG
               printf ("LOGICAL: First cld layer present. set others to N not M!\n");
#endif
               }



#if DEBUG
            if (current_qcfptr->sqlflg == 'M' && current_qcfptr->spdflg != 'M')
               printf ("LOGICAL: Squall/Gust winds should be N not M!!\n");
#endif

            /*---------------------------------------------
             *  Squall/Gust winds should be not available
             *  instead of Missing unless winds are missing.
             *---------------------------------------------*/
            if (current_qcfptr->sqlflg == 'M' && current_qcfptr->spdflg != 'M')
               current_qcfptr->sqlflg = 'N';


            /*--------------------------------------------------------------
             * Dew point should be less than or equal to temperature.
             * Else flag both as dubious. Don't change M,N,C,I,X, B,D flags.
             *--------------------------------------------------------------*/
            if ((current_qcfptr->dewpnt > current_qcfptr->temp) &&
                (current_qcfptr->dewpnt > -999.00 && current_qcfptr->temp > -999.00))
               {
               if (current_qcfptr->tmpflg == 'G') current_qcfptr->tmpflg = 'D';
               if (current_qcfptr->dewflg == 'G') current_qcfptr->dewflg = 'D';

#if DEBUG
               printf ("LOGICAL: Dew point is > temp...reset flags to at least D!!\n");
#endif
               }

            /*---------------------------------------------
             * Wind speed must be >=0.0 and not missing.
             *--------------------------------------------*/
            if (current_qcfptr->wndspd <0.0 && current_qcfptr->wndspd > -999.00)
               current_qcfptr->spdflg = 'B';

#if DEBUG
            if (current_qcfptr->wndspd <0.0 && current_qcfptr->wndspd > -999.00)
               printf ("LOGICAL: Wind speed must be >=0.0!!\n");
#endif

            /*-----------------------------------------------
             * Wind dir must be >0 && < 360 and not missing.
             *----------------------------------------------*/
            if ( current_qcfptr->wnddir > -999.00 && 
                 (current_qcfptr->wnddir <0.0 || current_qcfptr->wnddir >360.0))
               current_qcfptr->dirflg = 'B'; 

#if DEBUG 
            if ( current_qcfptr->wnddir > -999.00 && 
                 (current_qcfptr->wnddir <0.0 || current_qcfptr->wnddir >360.0))
               printf ("LOGICAL: Wind dir must be >0 or <360!!\n"); 
#endif 

            /*-----------------------------------------------------
             * If Wind speed is 0 (calm), set wind dir = 0.
             * AND set wind dir QC flag same as wind speed QC flag.
             *----------------------------------------------------*/
            if ( current_qcfptr->wndspd == 0.0)
               {
               current_qcfptr->wnddir = 0.0;
               current_qcfptr->dirflg = current_qcfptr->spdflg;
#if DEBUG 
               printf ("LOGICAL: Wind speed =0.0. Reset wind dir and qc flags!!\n"); 
#endif 
               }

            /*-----------------------------------------------------------------
             * Use Calculated sea level pressure to flag the station
             * pressure and sea level pressures if they are present...
             * If CSLP is not avail for some reason but SLP is available,
             * use the SLP flag to set the Stn Pressure flag. If neither
             * CSLP or SLP are available, then leave Stn Pressure flag
             * as 'U' for unchecked. Do this setting of QC flags
             * as long as the CSLP (of SLP) flag != M,N,X,I,C or U. Note that
             * I for insufficient can only occur on computed values
             * such as CSLP or dew point.
             *
             * NOTE: There is no need to even QC Stn Pressures since they
             *   can not really be compared. The s/w above that does these
             *   Stn Pressure comparisons has been commented out only...not
             *   yet removed....just in case. Also, we still allow (in 
             *   compute_sigma.c) sigma values to be computed and printed
             *   for stn pressure even though they are not needed for HQC.
             *   This is because this whole processes is still under
             *   development.
             *-----------------------------------------------------------------*/
            if (current_qcfptr->cmpflg !='M' && current_qcfptr->cmpflg !='N' &&
                current_qcfptr->cmpflg !='X' && current_qcfptr->cmpflg !='U' &&
                current_qcfptr->cmpflg !='I' && current_qcfptr->cmpflg !='C')
               {
               if (current_qcfptr->seaflg !='M' && current_qcfptr->seaflg !='N' &&
                   current_qcfptr->seaflg !='X' && current_qcfptr->seaflg !='C')
                  current_qcfptr->seaflg = current_qcfptr->cmpflg;

               if (current_qcfptr->staflg !='M' && current_qcfptr->staflg !='N' &&
                   current_qcfptr->staflg !='X' && current_qcfptr->staflg !='C') 
                  current_qcfptr->staflg = current_qcfptr->cmpflg;
#if DEBUG 
               printf ("LOGICAL: Reset pressure QC flags using CSLP qcflag!!\n"); 
#endif 

               }
            else if (current_qcfptr->seaflg !='M' && current_qcfptr->seaflg !='N' &&
                     current_qcfptr->seaflg !='X' && current_qcfptr->seaflg !='C' &&
                     current_qcfptr->seaflg !='U')
               {
               if (current_qcfptr->staflg !='M' && current_qcfptr->staflg !='N' &&
                   current_qcfptr->staflg !='X' && current_qcfptr->staflg !='C')
                  current_qcfptr->staflg = current_qcfptr->seaflg;
#if DEBUG  
               printf ("LOGICAL: Reset pressure QC flags using Sea Lvl P qcflag!!\n");  
#endif  
               }


            /*-------------------------------------------
             * Save QC'd rec in array for later printing.
             *------------------------------------------*/
            copy_qcfrec(qcfptr_array[mm], current_qcfptr);

            } /* for all stns at current hour and minute. (mm) */


         /*-----------------------------------------------
          * Write out chunk of QC'd qcfrecs for this time.
          * In the order read.
          *-----------------------------------------------*/
         for (zz=0;zz<numstns;zz++)    
            {
            index = print_order[zz];
            write_qcfrec (&qcf_output_stream, qcfptr_array[index]);
            reset_qcfrec (qcfptr_array[index]); /* blank out for next time */
            }

         } /* while data in input file  - Read next set of data for next time.*/

      printf ("Completed processing input_stream for %d. Go to next date\n", current_date);

      close_file (&input_stream);
      close_file (&qcf_output_stream);

      } /* for current_date = begin to end */

   if (data_rollsover)
      {
      /*---------------------------------------------
       * Data that ran from begin_date to end of
       * current year has been processed. Now setup
       * and process data from beginning of next
       * year to original end_date. Update the
       * century, etc.
       *--------------------------------------------*/
      begin_jdate = first_julian_day_in_nextyr;
      end_jdate = saved_end_jdate;

      current_yr++;
      if (current_yr == 100)
         {
         current_yr = 0;
         current_century++;
         }

      data_rollsover = 0; /* set to stop processing */

      printf ("(end while) data_rollsover\n");
      printf ("New dates: begin_jdate, end_jdate:: %d %d\n",
               begin_jdate, end_jdate);
      printf ("New dates: current_yr, current_century:: %d %d\n",
               current_yr, current_century);
      }
   else
      {
      /*----------------------------------------
       * Data did not rollover into next yr.
       * All data has now been processed. Exit.
       *---------------------------------------*/
      printf ("Data did NOT rollover into next yr -- end while\n");
      data_to_process = 0;
      }

   } /* while data_to_process */

   /*----------------------------------------------
    * Free all pointers created during processing.
    *---------------------------------------------*/
   destruct_qcfptr (&qcfptr);
   destruct_qcfptr (&current_qcfptr);

   for (ii=0;ii<MAXNUMSTNS;ii++)
      destruct_qcfptr (&qcfptr_array[ii]);

   }  /* main() */
