<html>
<head>
   <title>How To: Build/Develop the ESC Extractor</title>
   <link rel="stylesheet" type="text/css" href="/css/howto.css" />
</head>
<body>
<h1>How To: Build/Develop the ESC Extractor</h1>

<a name="top"></a>
<h2>Contents</h2>
<ol>
    <li><a href="#about">About</a></li>
    <li><a href="#build">Build</a></li>
    <li><a href="#develop">Development</a></li>
    <li><a href="#algorithm">Algorithms</a></li>
</ol>
<hr />

<a name="about"></a>
<h2>About</h2>
<p><h3>This document was originally written by Joel Clawson in August 2007.  The documentation was updated in April 2019.  JNS</h3></p>
<p>This document contains information that may be useful for anyone working on the development of the ESC Extractors.  This includes upgrading existing pieces or adding new extraction classes to the set.</p>
<p>The software described in this document is written in Java 1.5 with the use of generics.  Java 1.5 or newer is required for the software to run.</p>
<p>The extraction software is designed to allow the base extractor to be extended to handle different types of extractions.  This allows different pressure or height level extractors to be created and use the same process as the other extractors without changing existing ones.</p>

<p><a href="#top">Top</a></p>
<hr />


<a name="build"></a>
<h2>Build</h2>
<p>The build is defined in the <i>build.xml</i> file and uses Ant.  If you have not configured Ant in your environment, you will need to follow the instructions <a href="https://internal.eol.ucar.edu/content/setup-and-use-ant-tool/#environment">here</a> or you won't be able to build the extractor with Ant.</p>

<h3>Directory Layout</h3>
<table class="directories">
   <tr>
      <th>build</th>
      <td>This directory may not exist initially, since it is removed when the <span class="softwareName">clean</span> command is run.  It contains the .class files generated after compiling the .java source.</td>
   </tr>
   <tr>
      <th>dist</th>
      <td>This directory is generated by the build when the jar file is being prepared for production.  This is used so the user can check the contents and layout before deploying it into production.  This directory is removed when the <span class="softwareName">clean</span> command is run.</td>
   </tr>
   <tr>
      <th>docs</th>
      <td>This directory contains all of the documentation for the extractors.  It also contains an API directory which is automatically generated during the creation of the javadoc and is removed when the <span class="softwareName">clean</span> command is executed.</td>
   </tr>
   <tr>
      <th>src</th>
      <td>This directory contains all of the .java source files for the extractors.</td>
   </tr>
   <tr>
      <th>testfiles</th>
      <td>This directory contains test soundings used with the JUnit tests for testing the extractors.  The files contain special cases at certain pressure levels or are odd soundings that contain some special case that requires testing.</td>
   </tr>
   <tr>
      <th>tests</th>
      <td>This directory contains the JUnit .java source files used for testing the extractors.  This does not contain any production software.</td>
   </tr>
</table>

<h3>build.xml Targets</h3>
<table class="directories">
   <tr>
      <th>clean</th>
      <td>Remove all generated content from the working area.  This removes the build, dist, and docs/api directories.</td>
   </tr>
   <tr>
      <th>compile</th>
      <td>Compile the extraction source code and prepare it for execution.  The .class files are put into the build directory.</td>
   </tr>
   <tr>
      <th>compileTests</th>
      <td>Compile the extraction test source code and prepare it to be run.  This requires the source files to be compiled and will perform the operation if necessary.</td>
   </tr>
   <tr>
      <th>deploy</th>
      <td>Copy the jar file to the production area and replace all of the public javadoc with a newly generated copy.  This will perform all necessary operations to create the jar file and generate the javadocs that have not already been performed.</td>
   </tr>
   <tr>
      <th>dist</th>
      <td>Generate the jar file to be used in production.  This will compile the .java files if they have not already been created.  The jar file does not contain any test software.</td>
   </tr>
   <tr>
      <th>javadoc</th>
      <td>Create the javadoc files for the non-test files.  This also copies all how tos listed in the overview with the API.  The files are added to the docs/api directory so the directory contents can be copied to the public area on deployment.</td>
   </tr>
   <tr>
      <th>test</th>
      <td>Execute the JUnit tests for the extractor.  All failures need to be addressed before the jar file is deployed.</td>
   </tr>
</table>


<p><a href="#top">Top</a></p>
<hr />


<a name="develop"></a>
<h2>Development</h2>
<p>The ESCExtractor class is designed as an abstract class to allow it to be extended to handle different pressure or height level extractions.  This also will allow for special case extractors to be developed to handle unique sounding instances.  Each extension defines the pressure or height level frequency (i.e. 5 mb, 50m), the number of seconds on either side of the interpolated time for a pressure or height level to be considered for end points, the smallest pressure or height value to be interpolated, and the main function to allow the extractor to be run.  This will also allow functions for the main algorithm to be overridden if necessary.</p>

<p><a href="#top">Top</a></p>
<hr />

<a name="algorithm"></a>
<h2>Extraction Algorithms</h2>
<p>The following is the set of algorithms used in the main extractor.</p>

<h3>Main Algorithm</h3>
<p>This is the main process the extractor goes through to interpolate all soundings found in the data directory.</p>
<ol>
   <li>Determine the list of soundings to be interpolated.</li>
   <li>Create an interpolated sounding for each sounding in the list.</li>
   <li>Write the interpolated sounding to its output file.
</ol>

<h3>Individual Sounding Interpolation Algorithm</h3>
<p>This algorithm is the entire process for interpolating a sounding.</p>
<ol>
   <li>Parse the sounding (also tests to make sure that it is a properly formatted sounding)</li>
   <li>Replace all unchecked flags with good (forces there to be no unchecked data)</li>
   <li>Copy sounding header and initial data record to the interpolated sounding.</li>
   <li>Determine starting pressure or height to be interpolated.</li>
   <li>Loop through the pressures or heights to be interpolated to calculate interpolated records and add to interpolated sounding.</li>
</ol>

<h3>Sounding Record Interpolation Algorithm</h3>
<p>This determines an individual interpolated record for a specific interpolated pressure or height.</p>
<ol>
   <li>Determine the list of records that can be used in the interpolation of the record.</li>
   <li>Interpolate the pressure, time, height, ascent rate, and pressure flag using end points determined from the pressure flag.</li>
   <li>Interpolate the temperature and temperature flag using end points determined from the temperature flag.</li>
   <li>Interpolate the relative humidity and rh flag using end points determined from the rh flag.</li>
   <li>Interpolate the four wind values, latitude, and longitude using end points determined from the U and V wind flags.</li>
</ol>

<h3>End Point Record List Algorithm</h3>
<p>This algorithm determines the list of records that can be used in determining the end points to use in value interpolation.</p>
<p class="note">This algorithm does not work if a sounding has all missing times or very few non-missing times.</p>
<ol>
   <li>Start from the last index used for the previous pressure or height level being interpolated.</li>
   <li>Advance through the sounding records searching for the record index such that the pressure or height at index is greater than or equal to the pressure or height being interpolated and the pressure or height at the following record is less than the pressure or height being interpolated and the calculated ascent rate between the indexed record and the last interpolated record is between -40 and 20 m/s.</li>
   <li>Use the records at index and index + 1 to interpolate the time the pressure or height occured or advance farther away from the interpolation pressure or height to determine the time if either records' time is missing.</li>
   <li>Use the interpolation time to move <i>n</i> seconds in either direction to be included in the end point list making sure to keep a record if it has a pressure or height equal to the interpolation pressure or height.</li>
</ol>
<p>This algorithm is a bit confusing and may seem overly complicated.  The added complication of the ascent rate check in the second step is to ignore records that are really screwed up.  Scot decided that ascent rates that exceed -40 m/s for dropsondes and 20 m/s for upsondes between the potential record and last interpolated record should not be possible end point records.  These ascent rates should be calculated from times and altitudes and not use either records actual ascent rate value.</p>
<p>The same bad records that require the -40 and 20 m/s ascent rate end points also require the searching of potential end points for an interpolation pressure or height to begin where the previous interpolation pressure or height stopped searching.  This is to ensure that potential records that would pass the requirements of an end point record, but occurred in the middle of a section of unacceptable records can not be included.  This is done for a couple of reasons.  First, use of the passable record will cause time sequence errors since the previous interpolated pressure or height time will seem to have occured after the current interpolated pressure's or height's time.  Second, if the passable record is amid some records that should not be considered, it is a reasonable assumption that the passable record may also be bad and really should not be considered either.</p>

<h3>End Point Calculation Algorithm</h3>
<ol>
   <li>Case 1:  A Record Exists with the Exact Interpolation Pressure or Height
      <ol>
         <li>Keep the value if the associated flag is better than the bad flag.</li>
         <li>Use Case 2 if the value's flag is bad or worse.</li>
      </ol>
   </li>
   <li>Case 2:  A Record Does Not Exist with the Exact Interpolation Pressure or Height
      <ol>
         <li>Search the potentinal end point list to find the record closest to the interpolation pressure or height with the best flag.</li>
         <li>Repeat the previous step to get the end point on the other side of the interpolation pressure or height.</li>
      </ol>
   </li>
</ol>


<h3>Value Interpolation Algorighm</h3>
<p>This value interpolation algorithm is the same for all of the interpolated values in a record.  The only difference is which end points are used, since they could be different from the different values' flags.</p>
<ol>
   <li>Only interpolate the value if the end points values are different and are not missing.</li>
   <li>interpolateValue = lower.value + ((interpolationPressure - upper.pressure) / (lower.pressure - upper.pressure) * (upper.value - lower.value)) <br> or using the appropriate height values instead of pressure values.</li>
</ol>
<p>This algorihm is a weighted average of the values based on the distance from the interpolation pressure or height.</p>


<p><a href="#top">Top</a></p>
<hr />

<p class="foot">Last Updated: April 2019 - J. Scannell</p>

</body>
</html>
